#!/usr/bin/env python3
"""
Инструмент для анализа безопасности сайта 100200.ru
Предназначен для тестирования собственного сайта на предмет уязвимостей
"""

import requests
import urllib.parse
import re
import time
import json
from urllib.robotparser import RobotFileParser
from concurrent.futures import ThreadPoolExecutor, as_completed
import argparse
import sys
from pathlib import Path

class VulnerabilityScanner:
    def __init__(self, base_url, delay=1):
        self.base_url = base_url.rstrip('/')
        self.delay = delay
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.results = {
            'directory_listing': [],
            'path_traversal': [],
            'admin_panels': [],
            'sensitive_files': [],
            'template_files': [],
            'errors': []
        }
        
    def log(self, message, level="INFO"):
        """Логирование с временными метками"""
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {level}: {message}")
        
    def make_request(self, url, method='GET', **kwargs):
        """Безопасный HTTP запрос с обработкой ошибок"""
        try:
            time.sleep(self.delay)  # Задержка между запросами
            response = self.session.request(method, url, timeout=10, **kwargs)
            return response
        except requests.exceptions.RequestException as e:
            self.log(f"Ошибка запроса к {url}: {e}", "ERROR")
            return None
            
    def check_directory_listing(self):
        """Проверка на уязвимость directory listing"""
        self.log("Проверка на directory listing...")
        
        # Общие директории для проверки
        directories = [
            '/admin/', '/wp-admin/', '/administrator/', '/phpmyadmin/',
            '/backup/', '/backups/', '/config/', '/includes/',
            '/templates/', '/themes/', '/uploads/', '/files/',
            '/images/', '/css/', '/js/', '/assets/',
            '/logs/', '/tmp/', '/temp/', '/cache/',
            '/.git/', '/.svn/', '/.env/', '/.htaccess'
        ]
        
        for directory in directories:
            url = self.base_url + directory
            response = self.make_request(url)
            
            if response and response.status_code == 200:
                # Проверяем признаки directory listing
                if any(indicator in response.text.lower() for indicator in [
                    'index of', 'parent directory', 'directory listing',
                    '[dir]', '[file]', 'name</th>', 'last modified'
                ]):
                    self.results['directory_listing'].append({
                        'url': url,
                        'status_code': response.status_code,
                        'content_length': len(response.text)
                    })
                    self.log(f"Найден directory listing: {url}", "WARNING")
                    
    def check_path_traversal(self):
        """Проверка на path traversal уязвимости"""
        self.log("Проверка на path traversal...")
        
        # Паттерны для path traversal
        traversal_patterns = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%252f..%252f..%252fetc%252fpasswd'
        ]
        
        # Параметры для тестирования
        test_params = ['file', 'path', 'page', 'include', 'template', 'view']
        
        for param in test_params:
            for pattern in traversal_patterns:
                url = f"{self.base_url}/?{param}={pattern}"
                response = self.make_request(url)
                
                if response and response.status_code == 200:
                    # Проверяем признаки успешного path traversal
                    if any(indicator in response.text.lower() for indicator in [
                        'root:x:', 'bin/bash', 'localhost', '127.0.0.1',
                        'windows', 'system32', 'drivers'
                    ]):
                        self.results['path_traversal'].append({
                            'url': url,
                            'pattern': pattern,
                            'status_code': response.status_code
                        })
                        self.log(f"Возможный path traversal: {url}", "WARNING")
                        
    def find_admin_panels(self):
        """Поиск административных панелей"""
        self.log("Поиск административных панелей...")
        
        admin_paths = [
            '/admin', '/wp-admin', '/administrator', '/phpmyadmin',
            '/admin.php', '/login.php', '/admin/login', '/dashboard',
            '/control', '/manage', '/panel', '/cpanel', '/webmail',
            '/admin/index.php', '/admin/login.php', '/admin/dashboard.php'
        ]
        
        for path in admin_paths:
            url = self.base_url + path
            response = self.make_request(url)
            
            if response and response.status_code in [200, 401, 403]:
                # Проверяем признаки админ панели
                if any(indicator in response.text.lower() for indicator in [
                    'login', 'password', 'username', 'admin', 'dashboard',
                    'control panel', 'administration', 'wp-login'
                ]):
                    self.results['admin_panels'].append({
                        'url': url,
                        'status_code': response.status_code,
                        'title': self.extract_title(response.text)
                    })
                    self.log(f"Найдена админ панель: {url}", "INFO")
                    
    def find_sensitive_files(self):
        """Поиск чувствительных файлов"""
        self.log("Поиск чувствительных файлов...")
        
        sensitive_files = [
            '/.env', '/.htaccess', '/.htpasswd', '/web.config',
            '/robots.txt', '/sitemap.xml', '/crossdomain.xml',
            '/phpinfo.php', '/info.php', '/test.php', '/config.php',
            '/database.php', '/db.php', '/settings.php', '/config.ini',
            '/.git/config', '/.svn/entries', '/composer.json',
            '/package.json', '/yarn.lock', '/package-lock.json'
        ]
        
        for file_path in sensitive_files:
            url = self.base_url + file_path
            response = self.make_request(url)
            
            if response and response.status_code == 200:
                self.results['sensitive_files'].append({
                    'url': url,
                    'status_code': response.status_code,
                    'content_length': len(response.text),
                    'content_preview': response.text[:200] + '...' if len(response.text) > 200 else response.text
                })
                self.log(f"Найден чувствительный файл: {url}", "WARNING")
                
    def find_template_files(self):
        """Поиск файлов шаблонов"""
        self.log("Поиск файлов шаблонов...")
        
        template_extensions = ['.php', '.html', '.htm', '.tpl', '.twig', '.blade.php']
        template_dirs = ['/templates/', '/themes/', '/views/', '/layouts/', '/includes/']
        
        for directory in template_dirs:
            url = self.base_url + directory
            response = self.make_request(url)
            
            if response and response.status_code == 200:
                # Ищем ссылки на файлы шаблонов
                template_links = re.findall(r'href=["\']([^"\']*\.(?:php|html|htm|tpl|twig))["\']', response.text, re.IGNORECASE)
                
                for link in template_links:
                    template_url = urllib.parse.urljoin(url, link)
                    template_response = self.make_request(template_url)
                    
                    if template_response and template_response.status_code == 200:
                        self.results['template_files'].append({
                            'url': template_url,
                            'status_code': template_response.status_code,
                            'content_length': len(template_response.text),
                            'file_type': Path(link).suffix
                        })
                        self.log(f"Найден файл шаблона: {template_url}", "INFO")
                        
    def extract_title(self, html_content):
        """Извлечение заголовка страницы"""
        title_match = re.search(r'<title[^>]*>(.*?)</title>', html_content, re.IGNORECASE | re.DOTALL)
        return title_match.group(1).strip() if title_match else "No title"
        
    def check_robots_txt(self):
        """Проверка robots.txt"""
        self.log("Проверка robots.txt...")
        
        robots_url = self.base_url + '/robots.txt'
        response = self.make_request(robots_url)
        
        if response and response.status_code == 200:
            self.log("robots.txt найден", "INFO")
            # Извлекаем пути из robots.txt
            disallowed_paths = re.findall(r'Disallow:\s*(.+)', response.text)
            for path in disallowed_paths:
                self.log(f"Disallowed path: {path.strip()}", "INFO")
                
    def run_full_scan(self):
        """Запуск полного сканирования"""
        self.log(f"Начинаем сканирование {self.base_url}")
        
        # Проверяем robots.txt первым
        self.check_robots_txt()
        
        # Запускаем все проверки
        checks = [
            self.check_directory_listing,
            self.check_path_traversal,
            self.find_admin_panels,
            self.find_sensitive_files,
            self.find_template_files
        ]
        
        for check in checks:
            try:
                check()
            except Exception as e:
                self.log(f"Ошибка при выполнении {check.__name__}: {e}", "ERROR")
                self.results['errors'].append(f"{check.__name__}: {e}")
                
    def save_results(self, filename='scan_results.json'):
        """Сохранение результатов сканирования"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, ensure_ascii=False, indent=2)
        self.log(f"Результаты сохранены в {filename}")
        
    def print_summary(self):
        """Вывод сводки результатов"""
        print("\n" + "="*60)
        print("СВОДКА РЕЗУЛЬТАТОВ СКАНИРОВАНИЯ")
        print("="*60)
        
        print(f"Directory Listing: {len(self.results['directory_listing'])} найдено")
        print(f"Path Traversal: {len(self.results['path_traversal'])} найдено")
        print(f"Admin Panels: {len(self.results['admin_panels'])} найдено")
        print(f"Sensitive Files: {len(self.results['sensitive_files'])} найдено")
        print(f"Template Files: {len(self.results['template_files'])} найдено")
        print(f"Errors: {len(self.results['errors'])} ошибок")
        
        if self.results['errors']:
            print("\nОШИБКИ:")
            for error in self.results['errors']:
                print(f"  - {error}")

def main():
    parser = argparse.ArgumentParser(description='Сканер уязвимостей для сайта 100200.ru')
    parser.add_argument('--url', default='https://100200.ru', help='URL для сканирования')
    parser.add_argument('--delay', type=float, default=1.0, help='Задержка между запросами (сек)')
    parser.add_argument('--output', default='scan_results.json', help='Файл для сохранения результатов')
    
    args = parser.parse_args()
    
    print("🔍 Сканер уязвимостей для сайта 100200.ru")
    print("⚠️  ВНИМАНИЕ: Используйте только на собственных сайтах!")
    print(f"🎯 Цель: {args.url}")
    print(f"⏱️  Задержка: {args.delay} сек")
    print("-" * 60)
    
    scanner = VulnerabilityScanner(args.url, args.delay)
    
    try:
        scanner.run_full_scan()
        scanner.print_summary()
        scanner.save_results(args.output)
        
    except KeyboardInterrupt:
        print("\n❌ Сканирование прервано пользователем")
        scanner.save_results(args.output)
    except Exception as e:
        print(f"\n❌ Критическая ошибка: {e}")
        scanner.save_results(args.output)

if __name__ == "__main__":
    main()
